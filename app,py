import gradio as gr

# check and convert input

def parse_input(text):
    if not text.strip():
        return None, "", "Input is empty."

    parts = text.split(",")
    nums = []
    for idx, p in enumerate(parts):
        token = p.strip()
        if token == "":
            return None, "", f"Missing value near position {idx+1}."
        if not token.lstrip("-").isdigit():
            return None, "", f"'{token}' is not an integer."
        nums.append(int(token))

    # Initialize state
    state = {
        "lst": nums,
        "i": 0,
        "j": 0,
        "n": len(nums),
        "finished": False,
        "log": [],
        "step_count": 0,
        "full_step_count": 0,
        "locked": False,   # Prevents actions after instant sort
        "swapped": False   # Tracks if a swap occurred in the pass
    }

    msg = f"Loaded list: {nums}"
    state["log"].append(f"[Step 0] {msg}")

    return state, msg, "\n".join(state["log"])


# 1 single sort step
def next_step(state):
    if state is None:
        return None, "Load a valid list first.", ""

    # if list is already sorted, lock it down
    if state.get("locked", False):
        return state, "Instant sort already used. Please load a new list.", "\n".join(state["log"])

    lst = state["lst"]
    i, j, n = state["i"], state["j"], state["n"]

    if state["finished"]:
        msg = f"Sorting complete: {lst}"
        state["step_count"] += 1
        state["log"].append(f"[Step {state['step_count']}] {msg}")
        return state, msg, "\n".join(state["log"])

    if n <= 1:
        state["finished"] = True
        msg = f"Nothing to sort: {lst}"
        state["step_count"] += 1
        state["log"].append(f"[Step {state['step_count']}] {msg}")
        return state, msg, "\n".join(state["log"])

    # End of pass
    if j >= n - i - 1:

        # Early stop: no swaps in the entire previous pass
        if not state.get("swapped", False):
            state["finished"] = True
            state["locked"] = True
            msg = f"No swaps in pass {i} → list sorted early: {lst}"
            state["step_count"] += 1
            state["log"].append(f"[Step {state['step_count']}] {msg}")
            return state, msg, "\n".join(state["log"])

        # Begin next pass
        state["i"] += 1
        state["j"] = 0
        state["swapped"] = False  # Reset swap flag for next pass

        msg = f"Starting pass {state['i']} | {lst}"
        state["step_count"] += 1
        state["log"].append(f"[Step {state['step_count']}] {msg}")
        return state, msg, "\n".join(state["log"])

    # Compare and possibly swap
    a, b = lst[j], lst[j+1]
    if a > b:
        lst[j], lst[j+1] = b, a
        state["swapped"] = True   # Swap occurred
        msg = f"Swapped {a} and {b} | {lst}"
    else:
        msg = f"Compared {a} and {b}, no change | {lst}"

    state["j"] += 1
    state["step_count"] += 1
    state["log"].append(f"[Step {state['step_count']}] {msg}")

    return state, msg, "\n".join(state["log"])


# insta-sort
def instant_sort(state):
    if state is None:
        return None, "Load a valid list first.", ""

    # block if sorted
    if state.get("locked", False):
        return state, "List already sorted instantly. Load a new list.", "\n".join(state["log"])

    lst = state["lst"][:]
    n = len(lst)
    step_counter = 0

    # Full bubble sort
    for i in range(n):
        swapped = False
        for j in range(n - i - 1):
            step_counter += 1
            if lst[j] > lst[j+1]:
                lst[j], lst[j+1] = lst[j+1], lst[j]
                swapped = True
        if not swapped:
            break

    state["full_step_count"] = step_counter
    state["locked"] = True  # LOCK state after instant sort

    msg = f"Instant sort: {lst} | Total steps: {step_counter}"
    state["log"].append(f"[Instant] {msg}")

    return state, msg, "\n".join(state["log"])


# Reset
def reset():
    return None, "Reset complete.", ""


# Gradio UI
with gr.Blocks() as demo:
    gr.Markdown("## Bubble Sort — Step-by-Step + Instant Sort")

    input_box = gr.Textbox(label="Enter comma-separated integers")
    load_btn = gr.Button("Load List")
    next_btn = gr.Button("Next Step")
    instant_btn = gr.Button("Instant Sort")
    reset_btn = gr.Button("Reset")

    status_box = gr.Textbox(label="Status (Latest Message)")
    log_box = gr.Textbox(label="Log", lines=14)
    state = gr.State(value=None)

    load_btn.click(parse_input, inputs=input_box, outputs=[state, status_box, log_box])
    next_btn.click(next_step, inputs=state, outputs=[state, status_box, log_box])
    instant_btn.click(instant_sort, inputs=state, outputs=[state, status_box, log_box])
    reset_btn.click(reset, outputs=[state, status_box, log_box])

demo.launch()

